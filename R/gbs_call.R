#' Genotype calls from allele count file
#' 
#' Genotype calls from allele count file
#' 
#' Function uses R/updog package (Gerard et al. 2018), which is based on a binomial model. If a sample has no reads at a marker, the genotype is NA and posterior probability equals 0. 
#' 
#' The input file follows the format generated by \code{\link{dart_tag}}, with the read counts for each marker x id combination represented as "count1|count2". 
#' 
#' Three output files are generated with the (1) allele ratio, (2) posterior mode, and (3) posterior mean.
#' 
#' @param in.file input file
#' @param out.base base name for output files
#' @param ploidy ploidy
#' @param n.core number of cores
#' 
#' @return marker x indiv matrix of read depths
#'
#' @export
#' @importFrom utils read.csv
#' @importFrom updog flexdog
#' @importFrom parallel makeCluster clusterExport parLapply stopCluster

gbs_call <- function(in.file, out.base, ploidy, n.core=1) {
  
  data <- read.csv(filename,header=F,check.names=F)
  data2 <- as.matrix(data[first.data.row:nrow(data),first.data.col:ncol(data)])
  data2 <- apply(data2,2,as.integer)
  id <- as.character(data[first.data.row-2,first.data.col:ncol(data)])
  
  x <- strsplit(data[first.data.row:nrow(data),1],split="|",fixed=T)
  marker <- sapply(x,"[",1)
  allele <- sapply(x,"[",2)
  allele <- gsub("Match","",allele)
  
  dimnames(data2) <- list(marker,id)
  ans1 <- apply(data2,2,
                FUN=function(u){v <- tapply(u,list(marker,allele),sum)
                                return(c(v[,"Ref"],v[,"Alt"]))})
  m <- nrow(ans1)/2
  n <- ncol(ans1)
  ref <- ans1[1:m,]
  alt <- ans1[m+1:m,]
  
  if (!is.null(AB.file)) {
    AB <- read.csv(AB.file)
    mark <- intersect(AB$marker,rownames(ref))
    m <- length(mark)
    stopifnot(m > 1)
    ref <- ref[mark,]
    alt <- alt[mark,]
    AB <- AB[match(mark,AB$marker),]
    ib <- AB$marker[AB$REF=="B"]
    tmp <- alt[ib,]
    alt[ib,] <- ref[ib,]
    ref[ib,] <- tmp
  }
  
  out <- list(depth=ref+alt,ratio=alt/(ref+alt))
  
  if (!is.null(PO.file)) {
    ans2 <- apply(rbind(ref,alt),2,
                  FUN=function(u){v <- split(u,f=rep(1:m,times=2))
                  sapply(v,paste,collapse="|")})
    rownames(ans2) <- rownames(alt)
    write.csv(ans2,file=PO.file)
  }
  
  f1 <- function(x,n,ploidy) {
    tmp <- try(flexdog(refvec=x[1:n],sizevec=x[n+1:n],ploidy=ploidy,model="norm",
                   verbose=FALSE),silent=TRUE)
    if (inherits(tmp,"try-error")) {
      return(c(NA*numeric(2*n),rep(0,n)))
    } 
    ix <- which(x[n+1:n]==0)
    if (length(ix) > 0) {
      tmp$geno[ix] <- NA
      tmp$postmean[ix] <- NA
      tmp$maxpostprob[ix] <- 0
    }
    return(c(tmp$geno,tmp$postmean,tmp$maxpostprob))
  }
              
  if (geno.call) {
    tmp <- split(cbind(alt,ref+alt),f=1:m)
  
    if (n.core==1) {
      ans <- lapply(tmp,f1,n=n,ploidy=ploidy)
    } else {
      cl <- makeCluster(n.core)
      clusterExport(cl=cl,varlist=NULL)
      ans <- parLapply(cl=cl,X=tmp,f1,n=n,ploidy=ploidy)
      stopCluster(cl)
    }
    ans <- matrix(unlist(ans),nrow=m,ncol=3*n,byrow = T)
    dimnames(ans) <- list(rownames(alt),rep(colnames(alt),times=3))
    out <- c(out,list(geno.mode=ans[,1:n],
                      prob=ans[,2*n+1:n],geno.mean=ans[,n+1:n]))
    stats <- data.frame(marker=rownames(alt),
                        depth0.1=apply(out$depth,1,quantile,p=0.1),
                        prob0.1=apply(out$prob,1,quantile,p=0.1))
    rownames(stats) <- NULL
  } else {
    stats <- data.frame(marker=rownames(alt),
                        depth0.1=apply(out$depth,1,quantile,p=0.1))
    rownames(stats) <- NULL
  }
  
  return(c(list(stats=stats),out))
}


